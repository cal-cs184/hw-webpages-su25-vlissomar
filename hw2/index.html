<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 2 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: <a href="https://cal-cs184.github.io/hw-webpages-su25-vlissomar/hw2/index.html">cs184.eecs.berkeley.edu/sp25</a>

		<br>
		
		Link to GitHub repository: <a href="https://github.com/cal-cs184/hw2-meshedit-orz1412">cs184.eecs.berkeley.edu/sp25</a>

		<figure>
			<img src="teapot.png" alt="Teapot" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Woodworking is 90% sanding. Similarly, in this homework, I've discovered that mesh manipulation is 80% pointers and 10% crying when a mesh face disappears for no (apparent) reason.
		On a more positive note, I finally understand why halfedges are compared to the 'glue' of the mesh. The halfedges hold all the relevant data about where it is in the mesh (stored in halfedge->vertex and halfedge->twin->vertex) and strictly unique mesh element assignments. Because the halfedges are so restricted, vertices, faces, and edges can just point to an arbitrary halfedge for consistent mesh traversal of any kind. 
		As for Bezier curves and surfaces, they're just made of lerps. Not too complicated.
			
		<h2>Section I: Bezier Curves and Surfaces</h2>

		<h3>Part 1: Bezier curves with 1D de Casteljau subdivision</h3>
		de Casteljau’s algorithm recursively reduces the number of control points by picking ‘new’ control points that are some fractional t (t : [0, 1]) of the way between two consecutive control points. For every n control points, there are only n - 1 edges like this. Each time our recursive de Casteljau step is called, we pick new control points until there is only 1 point, which is just defined as a point on the curve. 


		<p>Recursive Steps of Bezier Curves</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="bezier_pt1 (1).png" width="400px"/>
				  <figcaption>Step 1</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="bezier_pt1 (2).png" width="400px"/>
				  <figcaption>Step 2</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="bezier_pt1 (3).png" width="400px"/>
				  <figcaption>Step 3</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="bezier_pt1 (4).png" width="400px"/>
				  <figcaption>Step 4</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="bezier_pt1 (5).png" width="400px"/>
				  <figcaption>Step 5</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="bezier_pt1 (6).png" width="400px"/>
				  <figcaption>Step 6</figcaption>
				</td>
			  </tr>
			</table>
		</div>
			
		<figure>
			<img src="hw2-bezier_pt1 (2).gif" alt="Teapot" style="width:50%"/>
			<figcaption>Bezier Curve with lerping t and different control points</figcaption>
		</figure>

		<h3>Part 2: Bezier surfaces with separable 1D de Casteljau</h3>
		Bezier curves can easily be extended to bezier surfaces because a curve is just a line. Naturally, we can also linearly interpolate across this curve, which is all Bezier curves are. We would also have to use a new parameter u, v instead of just t so we can cover a 2D area, as opposed to a 1D line.

		<figure>
			<img src="bezier_teapot.png" alt="Teapot" style="width:50%"/>
			<figcaption>Bezier Teapot</figcaption>
		</figure>
		<h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>

		<h3>Part 3: Area-weighted vertex normals</h3>
		<ol type="1">
			<li>Initialize our return Vector3D, vert_norm</li>
			<li>Get the halfedge of this vertex. We start our while loop from here, until we reach this same edge again</li>
			<li>Since we are guaranteed triangle meshes for this assignment, we collect the other two Vector3D coordinates of the vertices in the current face by halfedge->next()</li>
			<li>Create edge vectors with v3 - v1 and v2 - v1, where v1 is our current vertex.</li>
			<li>Compute the crossproduct, V. This actually gives us both the area and the normal vector of the current face
				<ol type="a">
					<li>Area = |V|/2 </li>
					<li>Normal vector = V / |V| </li>
				</ol>
			</li>
			<li>Vert_norm += area * normal_vector</li>
			<li>When the loop ends, normalize vert_norm and return it</li>
		</ol>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="flat_teapot.png" width="400px"/>
				  <figcaption>Flat Shading</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="smooth_teapot.png" width="400px"/>
				  <figcaption>Smooth Shading</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h3>Part 4: Edge flip</h3>
		The edge flip method was miraculously bug-free despite not following the recommendation of re-assigning attributes for all mesh objects. I probably got lucky. To avoid losing pointers, I made a reference for all 6 relevant halfedges, and just reassigned their next() and face() pointers (after first ensuring that the faces  pointed to a correct halfedge in the new orientation). The flipped edge e0's halfedges are the only ones that get their vertex reassigned. Then, the vertices on either side of e0 pre-flip get reassigned halfedges just in case they pointed to the flipping halfedges.

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="preFlip_teapot.png" width="400px"/>
				  <figcaption>Before</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="postFlip_teapot.png" width="400px"/>
				  <figcaption>After</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		
		<h3>Part 5: Edge split</h3>
		Here's where I mess up. My first error was that I had to declare and initialize all new objects before referencing them, but I didn't initialize. My pointers were assigned the c++ equivalent of None or null objects. This took a long time to fix because I somehow completely missed that there were given methods newVertex, newFace, newHalfedge, etc. By the time I figured that out, I had a different issue: my code stopped crashing, but on every edge split, two of the four smaller faces would just drop out of existence. What this looked like, is that instead of being a normal, bright surfaced teapod, I had smaller dark triangles that, when hovered over, had 20 different edges, halfedges, faces, vertices at what looked to be random aread. 2 hours later, I discover thes new edges I seemed to have created are actually just part of the other side of the mesh. <br>
		Finally, with typical debugging (very many print statements), I figure out I dropped a face's halfedge pointer in my helper function. <br>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="preSplit.png" width="400px"/>
				  <figcaption>Before: splits</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="postSplit.png" width="400px"/>
				  <figcaption>After: splits</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="preSplitFlip.png" width="400px"/>
				  <figcaption>Before: splits, flips</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="postSplitFlip.png" width="400px"/>
				  <figcaption>After: splits, flips</figcaption>
				</td>
			  </tr>
			</table>
		</div>
			
		Structure-wise, I used the splitEdge function to simply split the edge (create 1 new edge, 2 halfedges, 1 vertex), and call a helper function on the vertex and the halfedge along the split edge if the associated face isn't the boundary. This worked great to handle split operations on boundary edges
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="boundary_preSplit.png" width="400px"/>
				  <figcaption>Before: boundary</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="boundary_postSplit.png" width="400px"/>
				  <figcaption>After: boundary</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h3>Part 6: Loop subdivision for mesh upsampling</h3>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Section III: Potential Extra Credit - Art Competition: Model something Creative</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>
